import{Token}from"./tokens.js";import*as n from"../runtime/nodes.js";import{N_functionDefinition,N_namespace,N_undefined,N_variable}from"../runtime/nodes.js";import{ESError,InvalidSyntaxError}from"../errors.js";import{tokenType,tokenTypeString,tt}from"./tokens.js";import{types}from"../runtime/primitiveTypes.js";export class ParseResults{constructor(){this.advanceCount=0,this.lastRegisteredAdvanceCount=0,this.reverseCount=0}registerAdvance(){this.advanceCount=1,this.lastRegisteredAdvanceCount++}register(t){return this.lastRegisteredAdvanceCount=t.advanceCount,this.advanceCount+=t.advanceCount,t.error&&(this.error=t.error),t.node}tryRegister(t){if(!t.error)return this.register(t);this.reverseCount+=t.advanceCount}success(t){return this.node=t,this}failure(t){return this.error=t,this}}export class Parser{constructor(t){this.tokens=t,this.tokenIdx=-1,this.currentToken=t[0],this.advance()}parse(){var t;if(!this.currentToken||!this.tokens||1===this.tokens.length&&this.tokens[0].type===tt.EOF)return new ParseResults;const e=this.statements(!0);return e.error||this.currentToken.type===tokenType.EOF?e:e.failure(new InvalidSyntaxError(null===(t=this.currentToken)||void 0===t?void 0:t.startPos,`Expected 'End of File', got token of type'${tokenTypeString[this.currentToken.type]}' of value ${this.currentToken.value}`))}advance(t){return t&&t.registerAdvance(),this.tokenIdx++,this.currentToken=this.tokens[this.tokenIdx],this.currentToken}reverse(t=1){return this.tokenIdx-=t,this.currentToken=this.tokens[this.tokenIdx],this.currentToken}consume(t,e,r){if(this.currentToken.type!==e)return t.failure(new InvalidSyntaxError(this.currentToken.startPos,null!=r?r:`Expected '${tokenTypeString[e]}' but got '${tokenTypeString[this.currentToken.type]}'`));this.advance(t)}clearEndStatements(t){for(;this.currentToken.type===tt.ENDSTATEMENT;)this.advance(t)}statements(t=!1){const e=new ParseResults,r=this.currentToken.startPos;let s=[];if(this.clearEndStatements(e),s.push(e.register(this.statement())),e.error)return e;let i=!0;for(;;){let t=0;for(;this.currentToken.type===tt.ENDSTATEMENT;)this.advance(e),t++;if(0===t&&(i=!1),!i)break;const r=e.tryRegister(this.statement());r?s.push(r):this.reverse(e.reverseCount)}this.clearEndStatements(e);let a=new n.N_statements(r,s);return t&&(a=new n.N_array(r,s,!0)),e.success(a)}statement(){const t=new ParseResults,e=this.currentToken.startPos;if(this.currentToken.matches(tt.KEYWORD,"return")){this.advance(t);let r=new N_undefined(this.currentToken.startPos);return this.currentToken.type!==tt.ENDSTATEMENT&&(r=t.register(this.expr())),t.success(new n.N_return(e,r))}if(this.currentToken.matches(tt.KEYWORD,"yield")){this.advance(t);let r=new N_undefined(this.currentToken.startPos);return this.currentToken.type!==tt.ENDSTATEMENT&&(r=t.register(this.expr())),t.success(new n.N_yield(e,r))}if(this.currentToken.matches(tt.KEYWORD,"break"))return this.advance(t),t.success(new n.N_break(e));if(this.currentToken.matches(tt.KEYWORD,"continue"))return this.advance(t),t.success(new n.N_continue(e));const r=t.register(this.expr());return t.error?t:t.success(r)}atom(){const t=new ParseResults,e=this.currentToken,r=this.currentToken.startPos;switch(e.type){case tt.NUMBER:return this.advance(t),t.success(new n.N_number(r,e));case tt.STRING:return this.advance(t),t.success(new n.N_string(r,e));case tt.IDENTIFIER:return this.atomIdentifier(t,r,e);case tt.OPAREN:this.advance(t);const s=t.register(this.expr());return t.error?t:this.currentToken.type==tt.CPAREN?(this.advance(t),t.success(s)):t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected ')'"));case tt.OSQUARE:let i=t.register(this.array());return t.error?t:t.success(i);case tt.OBRACES:let a=t.register(this.object());return t.error?t:t.success(a);case tt.KEYWORD:if("if"===e.value){const e=t.register(this.ifExpr());return t.error?t:t.success(e)}return t.failure(new InvalidSyntaxError(this.currentToken.startPos,`Invalid Identifier ${e.value}`));default:return t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected number, identifier, '(', '+' or '-'"))}}atomIdentifier(t,e,r){this.advance(t);let s=new n.N_variable(r),i=new n.N_undefined(e),a=!1;for(;-1!==[tt.OPAREN,tt.OSQUARE,tt.DOT].indexOf(this.currentToken.type);)switch(this.currentToken.type){case tt.OPAREN:a=!0;const e=s;if(s=t.register(this.makeFunctionCall(s,i)),i=e,t.error)return t;break;case tt.OSQUARE:if(i=s,s=t.register(this.makeIndex(s)),t.error)return t;break;case tt.DOT:if(this.advance(t),this.currentToken.type!==tt.IDENTIFIER)return t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected identifier after '.'"));i=s,s=new n.N_indexed(this.currentToken.startPos,s,new n.N_string(this.currentToken.startPos,this.currentToken)),this.advance(t)}if(this.currentToken.type===tt.ASSIGN){let r=this.currentToken.value;if(a)return t.failure(new InvalidSyntaxError(e,"Cannot assign to return value of function"));this.advance(t);const i=t.register(this.expr());if(s instanceof n.N_variable)s=new n.N_varAssign(e,s.a,i,r,!1);else{if(!(s instanceof n.N_indexed))return t.failure(new InvalidSyntaxError(e,`Cannot have node of type ${this.currentToken.constructor.name}. \n                            Expected either index or variable node.`));s.value=i,s.assignType=r}if(t.error)return t}return t.success(s)}power(){return this.binOp((()=>this.atom()),[tokenType.POW],(()=>this.factor()))}factor(){const t=new ParseResults,e=this.currentToken;switch(e.type){case tt.SUB:case tt.ADD:this.advance(t);const r=t.register(this.factor());return t.error?t:t.success(new n.N_unaryOp(e.startPos,r,e));default:return this.power()}}term(){return this.binOp((()=>this.factor()),[tt.MUL,tt.DIV])}arithmeticExpr(){return this.binOp((()=>this.term()),[tt.ADD,tt.SUB])}comparisonExpr(){const t=new ParseResults;if(this.currentToken.type===tt.NOT){const e=this.currentToken;this.advance(t);let r=t.register(this.expr());return t.error?t:t.success(new n.N_unaryOp(e.startPos,r,e))}let e=t.register(this.binOp((()=>this.arithmeticExpr()),[tt.EQUALS,tt.NOTEQUALS,tt.GT,tt.GTE,tt.LTE,tt.LT]));return t.error?t:t.success(e)}expr(){const t=new ParseResults;if(this.clearEndStatements(t),this.currentToken.type===tt.KEYWORD&&-1!==["var","let","global","mutable","const","local"].indexOf(this.currentToken.value))return this.initiateVar(t);if(this.currentToken.matches(tokenType.KEYWORD,"if"))return this.ifExpr();if(this.currentToken.matches(tokenType.KEYWORD,"while"))return this.whileExpr();if(this.currentToken.matches(tokenType.KEYWORD,"for"))return this.forExpr();if(this.currentToken.matches(tokenType.KEYWORD,"func"))return this.funcExpr();if(this.currentToken.matches(tokenType.KEYWORD,"class"))return this.classExpr();if(this.currentToken.matches(tokenType.KEYWORD,"namespace"))return this.namespace();let e=t.register(this.binOp((()=>this.comparisonExpr()),[tt.AND,tt.OR]));return t.error?t:t.success(e)}binOp(t,e,r=t){const s=new ParseResults;let i=s.register(t());if(s.error)return s;for(;-1!==e.indexOf(this.currentToken.type)||-1!==e.indexOf([this.currentToken.type,this.currentToken.value]);){const t=this.currentToken;this.advance(s);const e=s.register(r());if(s.error)return s;i=new n.N_binOp(i.startPos,i,t,e)}return s.success(i)}typeExpr(){const t=new ParseResults;if(this.currentToken.type!==tt.IDENTIFIER)return t.failure(new InvalidSyntaxError(this.currentToken.startPos.clone,"Expected an identifier"));let e=this.currentToken;return this.advance(t),t.success(new N_variable(e))}makeFunctionCall(t,e=new n.N_undefined){const r=new ParseResults;let s=[];const i=this.currentToken.startPos;if(this.currentToken.type!==tt.OPAREN)return r.failure(new InvalidSyntaxError(i,"Expected '['"));if(this.advance(r),this.currentToken.type===tt.CPAREN)return this.advance(r),r.success(new n.N_functionCall(i,t,[]));if(s.push(r.register(this.expr())),r.error)return r.failure(new InvalidSyntaxError(this.currentToken.startPos,"Invalid argument"));for(;this.currentToken.type===tt.COMMA;)if(this.advance(r),s.push(r.register(this.expr())),r.error)return r;return this.currentToken.type!==tt.CPAREN?r.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected ',' or ')'")):(this.advance(r),r.success(new n.N_functionCall(i,t,s)))}makeIndex(t){const e=new ParseResults,r=this.currentToken.startPos,s=t;if(this.currentToken.type!==tt.OSQUARE)return e.failure(new InvalidSyntaxError(r,"Expected '["));if(this.advance(e),this.currentToken.type===tt.CSQUARE)return e.failure(new InvalidSyntaxError(r,"Cannot index without expression"));let i=e.register(this.expr());return e.error?e.failure(new InvalidSyntaxError(this.currentToken.startPos,"Invalid index")):this.currentToken.type!==tt.CSQUARE?e.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected ']'")):(this.advance(e),e.success(new n.N_indexed(r,s,i)))}initiateVar(t){let e=this.currentToken.startPos,r=!1,s=!1,i=!1,a=!1;if(this.currentToken.type===tt.KEYWORD&&-1!==["var","let"].indexOf(this.currentToken.value)&&(a=!0,s=!0,this.advance(t),t.error))return t;if(this.currentToken.type===tt.KEYWORD&&-1!==["global","local"].indexOf(this.currentToken.value)&&(a=!0,"global"===this.currentToken.value?i=!0:s=!0,this.advance(t),t.error))return t;if(this.currentToken.type===tt.KEYWORD&&-1!==["const","mutable"].indexOf(this.currentToken.value)&&(a=!0,"const"===this.currentToken.value&&(r=!0),this.advance(t),t.error))return t;if(this.currentToken.type===tt.KEYWORD)return t.failure(new InvalidSyntaxError(this.currentToken.startPos,`Expected Identifier 'var', 'let', 'const', 'mutable', 'local', or 'global', not ${this.currentToken.value}`));if(this.currentToken.type!==tokenType.IDENTIFIER)return t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected Identifier or Keyword"));const o=this.currentToken;this.advance(t);let c=types.any;if(this.currentToken.type===tt.COLON&&(a=!0,this.consume(t,tt.COLON),c=t.register(this.typeExpr())),this.currentToken.type!==tt.ASSIGN)return r?t.failure(new InvalidSyntaxError(e,"Cannot initialise constant to undefined")):t.success(new n.N_varAssign(e,o,new n.N_undefined(this.currentToken.startPos),"=",i,s,r,a,c));let u=this.currentToken.value;this.advance(t);const h=t.register(this.expr());return t.error?t:((h instanceof n.N_class||h instanceof n.N_functionDefinition)&&(h.name=o.value),h instanceof N_namespace&&(h.name=o.value,h.mutable=!r),t.success(new n.N_varAssign(e,o,h,u,i,s,r,a,c)))}bracesExp(){const t=new ParseResults;if(this.currentToken.type!==tt.OBRACES){const e=t.register(this.statement());return t.error?t:(this.clearEndStatements(t),t.success(e))}if(this.advance(t),this.clearEndStatements(t),this.currentToken.type===tt.CBRACES)return this.advance(t),t.success(new n.N_undefined(this.currentToken.startPos));const e=t.register(this.statements());return t.error?t:this.currentToken.type!==tt.CBRACES?t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected '}'")):(this.advance(t),t.success(e))}addEndStatement(t){this.tokens.splice(this.tokenIdx,0,new Token(this.currentToken.startPos,tt.ENDSTATEMENT)),this.reverse(),this.advance(t)}ifExpr(){const t=new ParseResults;let e,r,s;const i=this.currentToken.startPos;return this.currentToken.matches(tt.KEYWORD,"if")?(this.advance(t),this.currentToken.type!==tt.OPAREN?t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected '(' after 'if'")):(this.advance(t),s=t.register(this.expr()),t.error?t:this.currentToken.type!==tt.CPAREN?t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected ')' after 'if (condition'")):(this.advance(t),e=t.register(this.bracesExp()),t.error?t:(this.clearEndStatements(t),this.currentToken.matches(tt.KEYWORD,"else")&&(this.advance(t),r=t.register(this.bracesExp()),t.error)?t:(this.addEndStatement(t),t.success(new n.N_if(i,s,e,r))))))):t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected 'if'"))}whileExpr(){const t=new ParseResults;let e,r;const s=this.currentToken.startPos;return this.currentToken.matches(tt.KEYWORD,"while")?(this.advance(t),this.currentToken.type!==tt.OPAREN?t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected '(' after 'while'")):(this.advance(t),r=t.register(this.expr()),t.error?t:this.currentToken.type!==tt.CPAREN?t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected ')' after 'while (condition'")):(this.advance(t),e=t.register(this.bracesExp()),t.error?t:(this.addEndStatement(t),t.success(new n.N_while(s,r,e)))))):t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected 'while'"))}parameter(t){let e,r=new n.N_any(types.any);if(this.currentToken.type!==tt.IDENTIFIER)return new InvalidSyntaxError(this.currentToken.startPos,"Expected identifier");if(e=this.currentToken.value,this.advance(t),this.currentToken.type===tt.COLON){if(this.consume(t,tt.COLON),t.error)return t.error;if(r=t.register(this.typeExpr()),t.error)return t.error}return{name:e,type:r}}funcCore(){const t=new ParseResults,e=this.currentToken.startPos;let r,s=[],i=new n.N_any(types.any);if(this.consume(t,tt.OPAREN),this.currentToken.type===tt.CPAREN)this.advance(t);else{let e=this.parameter(t);if(e instanceof ESError)return t.failure(e);for(s.push(e);this.currentToken.type===tt.COMMA;){this.advance(t);let e=this.parameter(t);if(e instanceof ESError)return t.failure(e);s.push(e)}if(this.currentToken.type!==tt.CPAREN)return t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected ',' or ')'"));this.advance(t)}if(this.currentToken.type===tt.COLON&&(this.advance(t),i=t.register(this.typeExpr()),t.error))return t;if(this.currentToken.type!==tt.OBRACES){if(r=new n.N_return(this.currentToken.startPos,t.register(this.expr())),t.error)return t}else{if(this.consume(t,tt.OBRACES),t.error)return t;if(r=this.currentToken.type!==tt.CBRACES?t.register(this.statements()):new n.N_undefined(this.currentToken.startPos),this.consume(t,tt.CBRACES),t.error)return t}return t.success(new n.N_functionDefinition(e,r,s,i))}funcExpr(){const t=new ParseResults;if(!this.currentToken.matches(tt.KEYWORD,"func"))return t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected 'func'"));this.advance(t);const e=t.register(this.funcCore());return t.error?t:t.success(e)}classExpr(t){const e=new ParseResults,r=this.currentToken.startPos,s=[];let i,a;if(!this.currentToken.matches(tt.KEYWORD,"class"))return e.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected 'class'"));if(this.advance(e),this.currentToken.matches(tt.KEYWORD,"extends")&&(this.advance(e),a=e.register(this.expr()),e.error))return e;if(this.consume(e,tt.OBRACES),e.error)return e;if(this.currentToken.type===tt.CBRACES)return this.advance(e),e.success(new n.N_class(r,[],void 0,void 0,t));for(;this.currentToken.type===tt.IDENTIFIER;){let t=this.currentToken.value;this.advance(e);const r=e.register(this.funcCore());if(e.error)return e;if(!(r instanceof N_functionDefinition))return e.failure(new ESError(this.currentToken.startPos,"ParseError",`Tried to get function, but got ${r} instead`));r.name=t,"init"===t?i=r:s.push(r)}return this.consume(e,tt.CBRACES),e.success(new n.N_class(r,s,a,i,t))}forExpr(){const t=new ParseResults,e=this.currentToken.startPos;let r,s,i,a=!1,o=!1;return this.currentToken.matches(tt.KEYWORD,"for")?(this.advance(t),this.consume(t,tt.OPAREN),this.currentToken.matches(tt.KEYWORD,"global")?(a=!0,this.advance(t)):this.currentToken.matches(tt.KEYWORD,"const")?(o=!0,this.advance(t)):(this.currentToken.matches(tt.KEYWORD,"var")||this.currentToken.matches(tt.KEYWORD,"let"))&&this.advance(t),this.currentToken.type!==tt.IDENTIFIER?t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected identifier")):(i=this.currentToken,this.advance(t),this.currentToken.matches(tt.KEYWORD,"in")?(this.advance(t),s=t.register(this.expr()),t.error?t:this.currentToken.type!==tt.CPAREN?t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected ')'")):(this.advance(t),r=t.register(this.bracesExp()),t.error?t:(this.addEndStatement(t),t.success(new n.N_for(e,r,s,i,a,o))))):t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected keyword 'in")))):t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected 'for'"))}array(){const t=new ParseResults;let e=[];const r=this.currentToken.startPos;if(this.currentToken.type!==tt.OSQUARE)return t.failure(new InvalidSyntaxError(r,"Expected '["));if(this.advance(t),this.currentToken.type===tt.CSQUARE)return this.advance(t),t.success(new n.N_array(r,[]));if(e.push(t.register(this.expr())),t.error)return t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected ']', 'var', 'if', 'for', 'while', number, identifier, '+', '-', '(', '[' or '!' 2"));for(;this.currentToken.type===tt.COMMA;)if(this.advance(t),e.push(t.register(this.expr())),t.error)return t;return this.currentToken.type!==tt.CSQUARE?t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected ',' or ']'")):(this.advance(t),t.success(new n.N_array(r,e)))}object(){const t=new ParseResults;let e=[];const r=this.currentToken.startPos;if(this.currentToken.type!==tt.OBRACES)return t.failure(new InvalidSyntaxError(r,"Expected '{"));if(this.advance(t),this.currentToken.type===tt.CBRACES)return this.advance(t),t.success(new n.N_emptyObject(r));for(;;){let r,s,i;if(this.currentToken.type===tt.IDENTIFIER)r="id",s=new n.N_string(this.currentToken.startPos,this.currentToken),this.advance(t);else if(this.currentToken.type===tt.STRING)r="string",s=new n.N_string(this.currentToken.startPos,this.currentToken),this.advance(t);else{if(this.currentToken.type!==tt.OSQUARE)break;if(r="value",this.advance(t),s=t.register(this.expr()),t.error)return t;if(this.currentToken.type!==tt.CSQUARE)return t.failure(new InvalidSyntaxError(this.currentToken.startPos,`Expected ']', got '${tokenTypeString[this.currentToken.type]}'`));this.advance(t)}if(this.currentToken.type===tt.COLON){if(this.advance(t),i=t.register(this.expr()),t.error)return t;if(this.currentToken.type!==tt.COMMA&&this.currentToken.type!==tt.CBRACES)return t.failure(new InvalidSyntaxError(this.currentToken.startPos,`Expected ',' or '}', got '${tokenTypeString[this.currentToken.type]}'`));this.currentToken.type===tt.COMMA&&this.advance(t)}else{if(this.currentToken.type!==tt.COMMA&&this.currentToken.type!==tt.CBRACES)return t.failure(new InvalidSyntaxError(this.currentToken.startPos,`Expected ',' or '}', got '${tokenTypeString[this.currentToken.type]}'`));if("id"!==r)return t.failure(new InvalidSyntaxError(this.currentToken.startPos,"You must specify a value when initialising an object literal with a key that is not an identifier.\n                        Try using `key: value` syntax."));this.reverse(),i=new n.N_variable(this.currentToken),this.advance(t),this.currentToken.type===tt.COMMA&&this.advance(t)}if(e.push([s,i]),t.error)return t}return this.currentToken.type!==tt.CBRACES?t.failure(new InvalidSyntaxError(this.currentToken.startPos,"Expected identifier, ',' or '}'")):(this.advance(t),t.success(new n.N_objectLiteral(r,e)))}namespace(){const t=new ParseResults,e=this.currentToken.startPos;if(this.consume(t,tt.KEYWORD),t.error)return t;if(this.consume(t,tt.OBRACES),t.error)return t;if(this.currentToken.type===tt.CBRACES)return this.advance(t),t.success(new n.N_namespace(e,new n.N_undefined));const r=t.register(this.statements());return t.error?t:(this.consume(t,tt.CBRACES),t.error?t:t.success(new n.N_namespace(e,r)))}}